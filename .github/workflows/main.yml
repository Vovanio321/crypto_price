name: Edit Telegram Message with Custom Emojis

on:
  workflow_dispatch:

jobs:
  edit-message:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install deps
        run: python3 -m pip install --upgrade pip telethon==1.31.3 requests

      - name: Edit Telegram Message
        env:
          TELETHON_API_ID: ${{ secrets.TELETHON_API_ID }}
          TELETHON_API_HASH: ${{ secrets.TELETHON_API_HASH }}
          TELETHON_SESSION: ${{ secrets.TELETHON_SESSION }}
        run: |
          python3 - <<'PY'
          import os, sys, asyncio
          import requests
          from requests.adapters import HTTPAdapter
          from requests.packages.urllib3.util.retry import Retry
          from telethon import TelegramClient, types
          from telethon.sessions import StringSession

          # Check secrets
          if not os.environ.get("TELETHON_API_ID") or not os.environ.get("TELETHON_API_HASH") or not os.environ.get("TELETHON_SESSION"):
              print("ERROR: TELETHON_API_ID / TELETHON_API_HASH / TELETHON_SESSION must be set in repo secrets")
              sys.exit(1)

          API_ID = int(os.environ['TELETHON_API_ID'])
          API_HASH = os.environ['TELETHON_API_HASH']
          SESSION = os.environ['TELETHON_SESSION']

          # Channel and message (not secret)
          CHANNEL = '@test_canal414'   # <- Ð·Ð°Ð¼ÐµÐ½Ð¸Ñ‚Ðµ Ð½Ð° Ð²Ð°Ñˆ ÐºÐ°Ð½Ð°Ð»/Ñ‡Ð°Ñ‚ (Ð¼Ð¾Ð¶Ð½Ð¾ @username Ð¸Ð»Ð¸ id)
          MESSAGE_ID = 8               # <- Ð·Ð°Ð¼ÐµÐ½Ð¸Ñ‚Ðµ Ð½Ð° id ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ

          # Coins & custom emoji ids (document_id or custom_emoji_id style)
          COINS = {"BTC": "90", "ETH": "80", "BNB": "2710"}
          EMOJI_IDS = {
              "BTC": 5213021529092170717,
              "ETH": 5215633431848848497,
              "BNB": 5212948037906766349
          }

          # Helper: utf-16 length (Bot API expects UTF-16 code units)
          def utf16_len(s: str) -> int:
              return len(s.encode("utf-16-le")) // 2

          # Robust get_prices with retries
          def get_prices():
              session = requests.Session()
              retries = Retry(total=3, backoff_factor=0.5, status_forcelist=[502,503,504,522,524])
              session.mount("https://", HTTPAdapter(max_retries=retries))
              url = f"https://api.coinlore.net/api/ticker/?id={','.join(COINS.values())}"
              r = session.get(url, timeout=10)
              r.raise_for_status()
              data = r.json()
              return {item["symbol"]: float(item["price_usd"]) for item in data}

          # Build entity with compatibility (document_id vs custom_emoji_id)
          def make_custom_entity(offset, length, emoji_id):
              try:
                  # preferred field name in some Telethon versions
                  return types.MessageEntityCustomEmoji(offset=offset, length=length, document_id=emoji_id)
              except TypeError:
                  return types.MessageEntityCustomEmoji(offset=offset, length=length, custom_emoji_id=emoji_id)

          async def main():
              client = TelegramClient(StringSession(SESSION), API_ID, API_HASH)
              await client.start()

              prices = get_prices()
              text = f"ðŸ“Š {prices['BTC']:.2f}$ ðŸ“Š {prices['ETH']:.2f}$ ðŸ“Š {prices['BNB']:.2f}$"

              fallback = "ðŸ“Š"
              # compute offsets using utf-16 code units for safety with API
              offsets = []
              running = ""
              for ch in text:
                  if ch == fallback:
                      offsets.append(utf16_len(running))
                  running += ch

              if len(offsets) != 3:
                  print("Unexpected fallback count in text:", text)
                  await client.disconnect()
                  sys.exit(1)

              coins = ["BTC", "ETH", "BNB"]
              length = utf16_len(fallback)

              entities = [ make_custom_entity(offsets[i], length, EMOJI_IDS[coins[i]]) for i in range(len(coins)) ]

              # Try editing once; if it fails, print error and exit (no sleeps)
              try:
                  await client.edit_message(entity=CHANNEL, message=MESSAGE_ID, text=text, entities=entities)
                  print("Edited message successfully.")
              except Exception as e:
                  print("Failed to edit message:", repr(e))
                  # fallback: try edit without entities to confirm connectivity
                  try:
                      await client.edit_message(entity=CHANNEL, message=MESSAGE_ID, text=text)
                      print("Edited message without custom emoji (fallback).")
                  except Exception as e2:
                      print("Fallback edit also failed:", repr(e2))
                      await client.disconnect()
                      sys.exit(1)

              await client.disconnect()

          asyncio.run(main())
          PY
